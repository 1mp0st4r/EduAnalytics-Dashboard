import { NextRequest, NextResponse } from "next/server"
import { neonService } from "../../../../lib/neon-service"

export async function POST(request: NextRequest) {
  try {
    const body = await request.json()
    const { riskLevels = ['Critical', 'High'], reportTypes = ['comprehensive'], scheduleFrequency = 'weekly' } = body

    // Get high-risk students - we need to get them one by one since neon service only accepts single risk level
    let allStudents = []
    for (const riskLevel of riskLevels) {
      const students = await neonService.getStudents({ 
        limit: 10000,
        riskLevel: riskLevel 
      })
      allStudents = [...allStudents, ...students]
    }
    
    // Remove duplicates based on student ID
    const uniqueStudents = allStudents.filter((student, index, self) => 
      index === self.findIndex(s => s.StudentID === student.StudentID)
    )
    const students = uniqueStudents

    if (!students || students.length === 0) {
      return NextResponse.json({
        success: true,
        message: "No high-risk students found for auto-scheduling",
        data: { scheduledReports: 0 }
      })
    }

    const scheduledReports = []

    // Schedule reports for each high-risk student
    for (const student of students) {
      for (const reportType of reportTypes) {
        const scheduleData = {
          id: `auto_${student.StudentID}_${reportType}_${Date.now()}`,
          studentId: student.StudentID,
          studentName: student.StudentName || 'N/A',
          reportType: reportType,
          scheduleFrequency: scheduleFrequency,
          nextRun: calculateNextRun(scheduleFrequency),
          isActive: true,
          autoGenerated: true,
          createdAt: new Date('2025-01-09').toISOString(),
          riskLevel: student.RiskLevel,
          priority: getPriority(student.RiskLevel)
        }

        scheduledReports.push(scheduleData)
      }
    }

    // Store scheduled reports (in a real implementation, this would be saved to database)
    // For now, we'll simulate storage
    console.log(`[AUTO-SCHEDULE] Scheduled ${scheduledReports.length} reports for ${students.length} students`)

    return NextResponse.json({
      success: true,
      message: `Successfully scheduled ${scheduledReports.length} reports for ${students.length} high-risk students`,
      data: {
        scheduledReports: scheduledReports.length,
        studentsProcessed: students.length,
        riskLevels: riskLevels,
        reportTypes: reportTypes,
        scheduleFrequency: scheduleFrequency,
        reports: scheduledReports.slice(0, 10) // Return first 10 for preview
      }
    })

  } catch (error) {
    console.error("[API] Error in auto-scheduling reports:", error)
    return NextResponse.json(
      { success: false, error: "Failed to auto-schedule reports" },
      { status: 500 }
    )
  }
}

export async function GET(request: NextRequest) {
  try {
    const { searchParams } = new URL(request.url)
    const riskLevel = searchParams.get('riskLevel')

    // Get high-risk students count
    const riskLevelsToCheck = riskLevel ? [riskLevel] : ['Critical', 'High']
    let allStudents = []
    for (const rl of riskLevelsToCheck) {
      const students = await neonService.getStudents({ 
        limit: 10000,
        riskLevel: rl 
      })
      allStudents = [...allStudents, ...students]
    }
    
    // Remove duplicates
    const uniqueStudents = allStudents.filter((student, index, self) => 
      index === self.findIndex(s => s.StudentID === student.StudentID)
    )
    const students = uniqueStudents

    const stats = {
      totalHighRiskStudents: students.length,
      criticalRiskStudents: students.filter(s => s.RiskLevel === 'Critical').length,
      highRiskStudents: students.filter(s => s.RiskLevel === 'High').length,
      mediumRiskStudents: students.filter(s => s.RiskLevel === 'Medium').length,
      lowRiskStudents: students.filter(s => s.RiskLevel === 'Low').length
    }

    return NextResponse.json({
      success: true,
      data: stats
    })

  } catch (error) {
    console.error("[API] Error getting auto-schedule stats:", error)
    return NextResponse.json(
      { success: false, error: "Failed to get auto-schedule statistics" },
      { status: 500 }
    )
  }
}

// Helper function to calculate next run time based on frequency
function calculateNextRun(frequency: string): string {
  const now = new Date()
  
  switch (frequency) {
    case 'daily':
      return new Date(now.getTime() + 24 * 60 * 60 * 1000).toISOString()
    case 'weekly':
      return new Date(now.getTime() + 7 * 24 * 60 * 60 * 1000).toISOString()
    case 'monthly':
      return new Date(now.getTime() + 30 * 24 * 60 * 60 * 1000).toISOString()
    default:
      return new Date(now.getTime() + 7 * 24 * 60 * 60 * 1000).toISOString()
  }
}

// Helper function to determine priority based on risk level
function getPriority(riskLevel: string): string {
  switch (riskLevel) {
    case 'Critical': return 'urgent'
    case 'High': return 'high'
    case 'Medium': return 'medium'
    case 'Low': return 'low'
    default: return 'medium'
  }
}
